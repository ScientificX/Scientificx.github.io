{"md5":"b2a11a81f7123f37fbcb18af519de43d","content":"<div id=\"content\">\n<p>\nBinary Trees are one of the simplest data structures to implement, indeed this is usually the second example used to teach recursion after the fibonaci is used \n</p>\n<!-- more -->\n<p>\nin haskell the basic structure for defining them is \n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span> <span class=\"type\">Bint</span> = <span class=\"type\">Empty</span></span></span><br><span class=\"line\">\t  | <span class=\"type\">Node</span> (<span class=\"type\">Bint</span> a) a (<span class=\"type\">Bint</span> b)</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\nIm begining a series of posts that will help document my progress through the book <a href=\"https://github.com/liuxinyu95/AlgoXY\">Elementary Algorithms</a>. I decided to read this book as it brings a fresh perpective in\nthe domain of algorithm books - it presents algorithms both in a functional and imperative manner contrasting and with full code snippets.\n</p>\n<div id=\"outline-container-orgd0f8c5f\" class=\"outline-2\">\n<h2 id=\"orgd0f8c5f\">Insertion into a Binary Search Tree</h2>\n<div class=\"outline-text-2\" id=\"text-orgd0f8c5f\">\n<p>\nTo insert k\n</p>\n<ul class=\"org-ul\">\n<li>case both branches are empty we insert the value here</li>\n<li>k &gt; than key then insert in right branch ; else</li>\n<li>k &lt; key insert in left branch</li>\n</ul>\n\n<p>\nIn haskell  \n</p>\n\n<div class=\"org-src-container\">\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">insert</span> <span class=\"type\">Empty</span> k = <span class=\"type\">Node</span> <span class=\"type\">Empty</span> k <span class=\"type\">Empty</span></span><br><span class=\"line\"><span class=\"title\">insert</span> (<span class=\"type\">Node</span> <span class=\"type\">Left</span> v <span class=\"type\">Right</span>) k = <span class=\"keyword\">case</span> k <span class=\"keyword\">of</span> </span><br><span class=\"line\">\t\t\t\t k &lt; x -&gt; <span class=\"type\">Node</span> (insert(<span class=\"type\">Left</span> k) x <span class=\"type\">Right</span>) </span><br><span class=\"line\">\t\t\t\t k &gt; x -&gt; <span class=\"type\">Node</span>(<span class=\"type\">Left</span> x insert(<span class=\"type\">Right</span> k))</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org7efc06b\" class=\"outline-2\">\n<h2 id=\"org7efc06b\">Tree Traversal</h2>\n<div class=\"outline-text-2\" id=\"text-org7efc06b\">\n<ul class=\"org-ul\">\n<li>Pre-order : key, Left, Right</li>\n<li>In-order : Left, key, Right</li>\n<li>Post-order : Left, Right, key</li>\n</ul>\n\n<p>\nWe can apply a map-like function to our tree during traversal like this\n</p>\n\n<p>\nInorder \n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">traverse</span> :: <span class=\"type\">Bint</span> -&gt; <span class=\"type\">Bint</span></span><br><span class=\"line\"><span class=\"title\">traverse</span> (<span class=\"type\">Node</span> <span class=\"type\">Empty</span> x <span class=\"type\">Empty</span>) f = <span class=\"type\">Empty</span></span><br><span class=\"line\"><span class=\"title\">traverse</span> (<span class=\"type\">Node</span> <span class=\"type\">Left</span> x <span class=\"type\">Right</span>) f = <span class=\"type\">Node</span> (traverse(<span class=\"type\">Left</span> f) f k traverse(<span class=\"type\">Right</span> f)) </span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n</div>\n"}
